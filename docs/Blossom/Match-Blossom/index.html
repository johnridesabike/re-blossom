<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Match-Blossom (Blossom.Match-Blossom)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">Blossom</a> &#x00BB; Match-Blossom</nav><h1>Module <code>Match-Blossom</code></h1><p><b>Res-Blossom</b> is a <a href="https://rescript-lang.org/">ReScript</a> implementation of the famous <a href="https://en.wikipedia.org/wiki/Blossom_algorithm">blossom algorithm</a>. It finds a maximum matching of vertices on general, undirected, weighted graphs.</p><p><a href="https://github.com/johnridesabike/re-blossom">Browse the source.</a></p><nav class="toc"><ul><li><a href="#installation">Installation</a></li><li><a href="#how-it-works">How it works</a><ul><li><a href="#functions">Functions</a></li><li><a href="#prepackaged-modules">Prepackaged modules</a></li><li><a href="#creating-comparables">Creating comparables</a></li></ul></li><li><a href="#changelog">Changelog</a></li><li><a href="#similar-packages">Similar packages</a><ul><li><a href="#javascript">JavaScript</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#credits">Credits</a></li></ul></nav></header><section><header><h2 id="installation"><a href="#installation" class="anchor"></a>Installation</h2><p>You can add Res-Blossom to your project by running:</p><pre><code class="ml">npm install res-blossom</code></pre><p>You will need to edit your project's <code>bsconfig.json</code> file and list Res-Blossom in the <code>bs-dependencies</code>.</p><pre><code class="ml">{
  &quot;bs-dependencies&quot;: [
    &quot;res-blossom&quot;
  ]
}</code></pre><p>You can now access this module as <code>Blossom.Match</code>.</p></header></section><section><header><h2 id="how-it-works"><a href="#how-it-works" class="anchor"></a>How it works</h2><p>Matching along an undirected, weighted graph is notoriously difficult. The blossom algorithm does the heavy lifting for us in O(n³) time. Let's look at a simple example.</p><p>Suppose you have a list of chess players, <code>[Mary, Joseph, Matthew, Mark, Luke,
John, Peter, Andrew, James, Philip]</code>, and you want to pair them to compete in a tournament round.</p><p>Your first step is to list all of your possible pairings.</p><pre><code class="ml">let graph = [
  (Mary, Joseph),
  (Mary, Matthew),
  (Joseph, Matthew),
  (Joseph, Mark),
  (Matthew, Luke),
  (Mark, Luke),
  (Mary, Andrew),
  (Luke, Peter),
  (Peter, John),
  (Andrew, Philip),
  (Mark, James)
];</code></pre><p>(Typically your list will be much longer, but this is just an illustration.)</p><p>Next, you will need to determine the <i>weight</i> of each pairing. This is a floating-point number that indicates how desirable that pairing is.</p><pre><code class="ml">let graph = [
  (Mary, Joseph, 40.),
  (Mary, Matthew, 40.),
  (Joseph, Matthew, 60.),
  (Joseph, Mark, 55.),
  (Matthew, Luke, 55.),
  (Mark, Luke, 50.),
  (Mary, Andrew, 15.),
  (Luke, Peter, 30.),
  (Peter, John, 10.),
  (Andrew, Philip, 10.),
  (Mark, James, 10.)
];</code></pre><p>In graph theory, each of the people is a &quot;vertex,&quot; and each pair of people is an &quot;edge.&quot; We can visualize it in 2D space.</p><pre>
  Andrew ---10--- Philip                  Peter
    |                                    /     \
   15                                  30       10
    |                                  /         \
   Mary ---40--- Matthew ---55---- Luke         John
      \          /                  /
       40      60                 50
        \      /                  /
         Joseph ------ 55 ----- Mark ----30---- James
</pre></header><div class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal">Internal</a>: { ... };</code></div><div class="spec module-type" id="module-type-Comparable"><a href="#module-type-Comparable" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Comparable">Comparable</a> = { ... };</code></div><dl><dt class="spec type" id="type-comparable"><a href="#type-comparable" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> comparable('vertex, 'id)</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-identity">identity</a> = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>)</span></code>;</dt><dd><p>A module of functions with a unique identity type. It is analogous to the type <code>Belt.Id.comparable</code>. Create one with the <a href="#val-comparable"><code>comparable</code></a> function or the <a href="MakeComparable"><code>MakeComparable</code></a> functor. Or create one with an existing <code>Belt.Id.comparable</code> module with <a href="#val-unsafeComparableFromBelt"><code>unsafeComparableFromBelt</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-cardinality"><a href="#type-cardinality" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> cardinality</code> = <code>[ </code><table class="variant"><tr id="type-cardinality.Max" class="anchored"><td class="def constructor"><a href="#type-cardinality.Max" class="anchor"></a><code>| </code><code>`Max</code></td></tr><tr id="type-cardinality.NotMax" class="anchored"><td class="def constructor"><a href="#type-cardinality.NotMax" class="anchor"></a><code>| </code><code>`NotMax</code></td></tr></table><code> ]</code>;</dt><dd><p>Represents whether or not the algorithm should <i>only</i> accept maximum-cardinality solutions.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> t('vertex, 'id)</code>;</dt><dd><p>A bi-directional, read-only mapping of each vertex to its mate vertex.</p></dd></dl><section><header><h3 id="functions"><a href="#functions" class="anchor"></a>Functions</h3></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: <span>?&#8288;cardinality:<a href="#type-cardinality">cardinality</a></span> <span>=&gt;</span> list(<span>(<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>, float)</span>) <span>=&gt;</span> <span>id:<a href="#type-comparable">comparable</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span></span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Computes a maximum-weighted matching on a general undirected weighted graph. This function takes time O(n³). See <code>usage</code> for examples of its use.</p><p>Accepts a list of tuples <code>(i, j, w)</code>, each describing an undirected edge between vertex <code>i</code> and vertex <code>j</code> with weight <code>w</code>. There is at most one edge between any two vertices, and no vertex has an edge to itself. Duplicate edges are ignored.</p><p><a href="Int#val-make"><code>Int.make</code></a> and <a href="String#val-make"><code>String.make</code></a> are prepackaged versions of this function for <code>int</code> and <code>string</code> vertices, respectively.</p><dl><dt>parameter cardinality</dt><dd><p>When set to <code>#Max</code>, only maximum-cardinality matchings are considered as solutions. <code>#NotMax</code> is the default.</p></dd></dl><dl><dt>parameter id</dt><dd><p>A first-class module created by <a href="#val-comparable"><code>comparable</code></a> or <a href="MakeComparable"><code>MakeComparable</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> option(<span class="type-var">'vertex</span>);</code></dt><dd><p>Returns <code>Some(mate)</code> for a mated vertex, or <code>None</code> if none exists.</p><pre><code class="ml">Blossom.Match.get(result, &quot;Mary&quot;) == Some(&quot;Joseph&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">let</span> reduce: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>init:<span class="type-var">'acc</span></span> <span>=&gt;</span> <span>f:<span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Reduces over the pairs of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">let list =
  Blossom.Match.reduce(
    result,
    ~init=list{},
    ~f=(acc, v1, v2) =&gt; list{(v1, v2), ...acc}
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-reduceU"><a href="#val-reduceU" class="anchor"></a><code><span class="keyword">let</span> reduceU: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>init:<span class="type-var">'acc</span></span> <span>=&gt;</span> <span>f:Js.Fn.arity3(<span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Reduces over the pairs of vertex mates. Each pair is used twice, once in each order.</p><p>Takes an uncurried <code>f</code> function.</p><pre><code class="ml">let list =
  Blossom.Match.reduce(
    result, 
    ~init=list{}, 
    ~f=(. acc, v1, v2) =&gt; list{(v1, v2), ...acc}
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>f:<span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> unit;</code></dt><dd><p>Iterates over the pairs of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">Blossom.Match.forEach(result, ~f=(v1, v2) =&gt; Js.log2(v1, v2))</code></pre></dd></dl><dl><dt class="spec value" id="val-forEachU"><a href="#val-forEachU" class="anchor"></a><code><span class="keyword">let</span> forEachU: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>f:Js.Fn.arity2(<span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> unit)</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Iterates over the pairs of vertex mates. Each pair is used twice, once in order.</p><p>Takes an uncurried <code>f</code> function.</p><pre><code class="ml">Blossom.Match.forEachU(result, ~f=(. v1, v2) =&gt; Js.log2(v1, v2))</code></pre></dd></dl><dl><dt class="spec value" id="val-toMap"><a href="#val-toMap" class="anchor"></a><code><span class="keyword">let</span> toMap: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> Belt.Map.t<span>(<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Returns a <code>Belt.Map.t</code> where each key is a vertex and each value is its mate.</p><pre><code class="ml">let map = Blossom.Match.toMap(result)
Belt.Map.get(map, &quot;Mary&quot;) == Some(&quot;Joseph&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span>(<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>)</span>);</code></dt><dd><p>Returns a list of tuples for each pair of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">Blossom.Match.toList(result) == list{
  (&quot;Raphael&quot;, &quot;Michael&quot;),
  (&quot;Peter&quot;, &quot;John&quot;),
  (&quot;Paul&quot;, &quot;James&quot;),
  (&quot;Michael&quot;, &quot;Raphael&quot;),
  (&quot;Mary&quot;, &quot;Joseph&quot;),
  (&quot;Joseph&quot;, &quot;Mary&quot;),
  (&quot;John&quot;, &quot;Peter&quot;),
  (&quot;James&quot;, &quot;Paul&quot;),
  (&quot;Gabriel&quot;, &quot;Andrew&quot;),
  (&quot;Andrew&quot;, &quot;Gabriel&quot;),
}</code></pre></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if there are no mates, <code>false</code> otherwise.</p><pre><code class="ml">Blossom.Match.isEmpty(result) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-has"><a href="#val-has" class="anchor"></a><code><span class="keyword">let</span> has: <a href="#type-t">t</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if the vertex has a mate, <code>false</code> otherwise.</p><pre><code class="ml">Blossom.Match.has(result, &quot;Mary&quot;) == true;</code></pre></dd></dl></section><section><header><h3 id="prepackaged-modules"><a href="#prepackaged-modules" class="anchor"></a>Prepackaged modules</h3></header><dl><dt class="spec module" id="module-Int"><a href="#module-Int" class="anchor"></a><code><span class="keyword">module</span> <a href="Int">Int</a>: { ... };</code></dt><dd><p>Prepackaged module for building graphs with <code>int</code> vertices.</p></dd></dl><dl><dt class="spec module" id="module-String"><a href="#module-String" class="anchor"></a><code><span class="keyword">module</span> <a href="String">String</a>: { ... };</code></dt><dd><p>Prepackaged module for building graphs with <code>string</code> vertices.</p></dd></dl></section><section><header><h3 id="creating-comparables"><a href="#creating-comparables" class="anchor"></a>Creating comparables</h3></header><dl><dt class="spec value" id="val-unsafeComparableFromBelt"><a href="#val-unsafeComparableFromBelt" class="anchor"></a><code><span class="keyword">let</span> unsafeComparableFromBelt: <span>id:Belt.Id.comparable<span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span></span> <span>=&gt;</span> <span>cmp:<span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)</span></span> <span>=&gt;</span> <a href="#type-comparable">comparable</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Turns a <code>Belt.Id.comparable</code> module into <a href="#type-comparable"><code>comparable</code></a>.</p><p>This is unsafe because the compiler can't guarantee the <code>cmp</code> value will be correct.</p><pre><code class="ml">module MyTypeCmp = Belt.Id.MakeComparable(MyType)
let blossomCmp =
  Blossom.Match.unsafeComparableFromBelt(
    ~id=module(MyTypeCmp),
    ~cmp=MyType.cmp
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-unsafeComparableFromBeltU"><a href="#val-unsafeComparableFromBeltU" class="anchor"></a><code><span class="keyword">let</span> unsafeComparableFromBeltU: <span>id:Belt.Id.comparable<span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span></span> <span>=&gt;</span> <span>cmp:Js.Fn.arity2(<span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)</span>)</span> <span>=&gt;</span> <a href="#type-comparable">comparable</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Turns a <code>Belt.Id.comparable</code> module into a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p><p>This is unsafe because the compiler can't guarantee the <code>cmp</code> value will be correct.</p></dd></dl><dl><dt class="spec module" id="module-MakeComparable"><a href="#module-MakeComparable" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeComparable">MakeComparable</a>:  (<a href="MakeComparable/argument-1-M">M</a>: { ... }) <span>=&gt;</span> <a href="#module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MakeComparable#type-t">t</a> = <a href="MakeComparable/argument-1-M#type-t">M.t</a>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a>.</p></dd></dl><dl><dt class="spec module" id="module-MakeComparableU"><a href="#module-MakeComparableU" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeComparableU">MakeComparableU</a>:  (<a href="MakeComparableU/argument-1-M">M</a>: { ... }) <span>=&gt;</span> <a href="#module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MakeComparableU#type-t">t</a> = <a href="MakeComparableU/argument-1-M#type-t">M.t</a>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p></dd></dl><dl><dt class="spec value" id="val-comparable"><a href="#val-comparable" class="anchor"></a><code><span class="keyword">let</span> comparable: <span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)</span> <span>=&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>)</span>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a>.</p><pre><code class="ml">module IntCmp = unpack(Match.comparable(compare: (int, int) =&gt; int))</code></pre></dd></dl><dl><dt class="spec value" id="val-comparableU"><a href="#val-comparableU" class="anchor"></a><code><span class="keyword">let</span> comparableU: Js.Fn.arity2(<span>(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)</span>) <span>=&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>)</span>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p></dd></dl><dl><dt class="spec value" id="val-comparableToBelt"><a href="#val-comparableToBelt" class="anchor"></a><code><span class="keyword">let</span> comparableToBelt: <a href="#type-comparable">comparable</a><span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> Belt.Id.comparable<span>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Turns a <a href="#type-comparable"><code>comparable</code></a> into a <code>Belt.Id.comparable</code>.</p></dd></dl></section></section><section><header><h2 id="changelog"><a href="#changelog" class="anchor"></a>Changelog</h2><p><a href="https://github.com/johnridesabike/re-blossom/blob/master/CHANGELOG.md">See the CHANGELOG.md file.</a></p></header></section><section><header><h2 id="similar-packages"><a href="#similar-packages" class="anchor"></a>Similar packages</h2></header><section><header><h3 id="javascript"><a href="#javascript" class="anchor"></a>JavaScript</h3><p>The <a href="https://www.npmjs.com/package/edmonds-blossom">edmonds-blossom</a> package uses the same algorithm. It should return the exact same pairings that this version does, but it doesn't have the flexibility of using different types.</p></header></section><section><header><h3 id="python"><a href="#python" class="anchor"></a>Python</h3><p><a href="http://jorisvr.nl/article/maximum-matching">Joris van Rantwijk's Python implementation</a> was the basis of both the JavaScript version and this ReScript version.</p></header></section></section><section><header><h2 id="credits"><a href="#credits" class="anchor"></a>Credits</h2><ul><li><a href="https://johnridesa.bike/">John</a> - idea and initial work.</li><li><a href="http://jorisvr.nl/">Joris van Rantwijk</a> - his Python code was an invaluable reference.</li></ul><p>I can't take any credit for the algorithm itself. It exists thanks to many people much smarter than me.</p></header></section></div></body></html>